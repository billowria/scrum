
import { format } from 'date-fns';

/**
 * Sanitizes and validates SQL queries generated by the AI.
 */
export const sanitizeSql = (sql) => {
    const clean = sql.trim().toLowerCase();

    if (!clean.startsWith('select')) {
        throw new Error("Only SELECT queries are authorized.");
    }

    const forbidden = ['insert', 'update', 'delete', 'drop', 'truncate', 'alter', 'create', 'grant', 'revoke'];
    for (const word of forbidden) {
        if (new RegExp(`\\b${word}\\b`, 'i').test(clean)) {
            throw new Error(`Forbidden operation detected: ${word}`);
        }
    }

    return sql;
};

/**
 * Strips AI thinking blocks and chain-of-thought reasoning.
 * DeepSeek R1 outputs reasoning as plain text without tags, so we need aggressive cleaning.
 */
export const cleanAiOutput = (text) => {
    if (!text) return '';

    let cleaned = text;

    // 1. Strip <think>...</think> blocks (closed)
    cleaned = cleaned.replace(/<think>[\s\S]*?<\/think>/gi, '');

    // 2. Strip unclosed <think> tags and everything after
    cleaned = cleaned.replace(/<think>[\s\S]*$/gi, '');

    // 3. AGGRESSIVE: DeepSeek R1 reasoning patterns - remove entire sentences
    // Split into paragraphs and keep only the last meaningful one
    const paragraphs = cleaned.split(/\n\n+/).filter(p => p.trim());

    if (paragraphs.length > 1) {
        // Take only the LAST paragraph - that's usually the final answer
        cleaned = paragraphs[paragraphs.length - 1].trim();
    }

    // 4. Remove lines that start with reasoning indicators
    const lines = cleaned.split('\n');
    const cleanedLines = lines.filter(line => {
        const trimmed = line.trim().toLowerCase();
        // Skip lines that are clearly "thinking out loud"
        if (trimmed.startsWith('since ')) return false;
        if (trimmed.startsWith('let me ')) return false;
        if (trimmed.startsWith('i need to ')) return false;
        if (trimmed.startsWith('i should ')) return false;
        if (trimmed.startsWith('i\'ll ')) return false;
        if (trimmed.startsWith('the response should ')) return false;
        if (trimmed.startsWith('keeping it ')) return false;
        if (trimmed.startsWith('just a ')) return false;
        if (trimmed.startsWith('no need ')) return false;
        if (trimmed.includes('as per the tone guidelines')) return false;
        if (trimmed.includes('i don\'t need to')) return false;
        if (trimmed.includes('sql queries')) return false;
        return true;
    });

    cleaned = cleanedLines.join('\n').trim();

    // 5. Final cleanup - remove common prefixes and curator leakage
    cleaned = cleaned.replace(/^(okay|alright|so|here'?s?|the answer is:?|the final response is:?|the response is:?)\s*/gi, '');
    cleaned = cleaned.replace(/^(straightforward|straightforward:)\s*/gi, '');

    // If nothing remains, return original last paragraph
    if (!cleaned && paragraphs.length > 0) {
        cleaned = paragraphs[paragraphs.length - 1].trim();
    }

    return cleaned.trim();
};

/**
 * Formats raw database results into a structured string for the Curator LLM.
 */
export const formatResultSet = (data) => {
    if (!data || (Array.isArray(data) && data.length === 0)) {
        return "RESULT: No data found for this query.";
    }

    if (Array.isArray(data)) {
        // If it's a huge result set, take the first 10
        const sample = data.slice(0, 10);
        const count = data.length;

        let str = `RESULT (${count} rows found):\n`;
        str += JSON.stringify(sample, (key, value) => {
            // STRICKLY HIDE IDs - Users do not want to see UUIDs
            if (key.toLowerCase().includes('id')) return undefined;
            if (key === 'created_at' || key === 'updated_at') return undefined;
            return value;
        }, 2);

        if (count > 10) str += `\n...and ${count - 10} more rows omitted.`;
        return str;
    }

    return `RESULT: ${JSON.stringify(data)}`;
};

/**
 * Gets the current world state for injection.
 */
export const getWorldState = () => {
    const now = new Date();
    return {
        currentDate: format(now, 'yyyy-MM-dd'),
        currentTime: format(now, 'HH:mm:ss'),
        dayOfWeek: format(now, 'EEEE'),
        timestamp: now.toISOString()
    };
};
